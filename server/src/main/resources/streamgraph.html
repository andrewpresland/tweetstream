<!DOCTYPE html>
<meta charset="utf-8">
<style>

  body {
    background-color: #404040;
  }

  text {
    font: 14px sans-serif;
    fill: #222;
  }

  .area text {
    font-size: 20px;
    text-anchor: middle;
  }

  .hidden {
    display: none;
  }

  .axis path {
    stroke: #cccccc
  }

  .axis line {
    stroke: #cccccc;
    stroke-width: 2px;
    shape-rendering: crispEdges;
  }

  .axis text {
    stroke: #cccccc
  }

  table align = "left" {
    font-family: sans-serif;
    table-layout: fixed;
    width: 1024px;
    text-align:left;
  }

  .line {
    fill: none;
    stroke: #666666;
    stroke-width: 2px;
  }

  tr {
    font-family: sans-serif;
  }

  tr:nth-of-type(odd) {
    background: #666666;
  }

  th {
    background: #666666;
    color: #cccccc;
    font-family: sans-serif;
    cursor: s-resize;
    background-repeat: no-repeat;
  }

  td,th {
    padding: 2px;
    border: 1px solid #666666;
    text-align: left;
  }

  .legend {
    font-size: 12px;
  }

  rect {
    stroke-width: 2;
  }

</style>

<svg width="1550" height="550"></svg>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3-legend/2.21.0/d3-legend.min.js"></script>
<script src="http://d3js.org/colorbrewer.v1.min.js"></script>
<script>

d3.json("http://localhost:9090/hashtags", function(hashtags) {

  var data = [];

  for (var i = 0; i < hashtags.length; i++) {
    data[i] = {};
    data[i]["Zero"]   = hashtags.five[i];
    data[i]["One"]    = hashtags.six[i];
    data[i]["Two"]    = hashtags.seven[i];
    data[i]["Three"]  = hashtags.eight[i];
    data[i]["Four"]   = hashtags.nine[i];
  }

var margin = { top: 10, right: 0, bottom: 10, left: 0 },
    width = 1550 - margin.left - margin.right,
    height = 500 - margin.top - margin.bottom,
    tags = ["Zero", "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine"],
    colors = ["Orange", "Gold", "YellowGreen", "DarkCyan", "Cyan","#6699ff", "#3377ff","#0055ff", "#0044cc", "#003399"];

var svg = d3.select("svg").append("g")
    .attr("transform", "translate(" + margin.left + " " + margin.top + ")");

var x = d3.scaleLinear().range([0, width]),
    y = d3.scaleLinear().range([height, 0]);

var series = svg.selectAll(".area")
  .data(tags)
  .enter()
  .append("g")
  .attr("class", "area");

series.append("path")
  .attr("fill", (d, i) => colors[i]);

series.append("text")
  .attr("dy", 5)
  .text(d => d);

var stack = d3.stack().keys(tags)
  .order(d3.stackOrderInsideOut)
  .offset(d3.stackOffsetWiggle);

var line = d3.line()
  .curve(d3.curveMonotoneX);

var xx = d3.scaleTime()
      .range([0, width]);

var axis = d3.axisBottom(xx);

svg.append("g")
  .attr("class", "axis")
  .attr("transform","translate(0," + height + ")")
  .call(axis);

  // Legend.
  var linearSize = d3.scaleLinear().domain([74, 11]).range([12.5, 4]);

  svg.append('g')
    .attr('class', 'legendColor')
    .attr('transform', 'translate(20, 0)');

  var colors = d3.scaleOrdinal()
      .domain( ["A", "B", "C", "D", "E"] )
      .range( ["Orange", "Gold", "YellowGreen", "DarkCyan", "Cyan"]);

  var legendColor = d3.legendColor()
    .scale(colors)
    .cells(4)
    .orient('vertical');

  svg.select(".legendColor")
    .call(legendColor);

  var stacked = stack(data);

  x.domain([0, data.length - 1]);
  y.domain([
    d3.min(stacked.map(d => d3.min(d.map(f => f[0])))),
    d3.max(stacked.map(d => d3.max(d.map(f => f[1]))))
  ]);

  series.data(stacked)
    .select("path")
    .attr("d", getPath);

  stacked.forEach(function(d, i){
    if (d[0][1] === d3.max(stacked.map(f => f[0][1]))) {
      d.top = true;
    }
    if (d[0][0] === d3.min(stacked.map(f => f[0][0]))) {
      d.bottom = true;
    }
  });

  series.select("text")
    .classed("hidden", false)
    .datum(getBestLabel)
    .classed("hidden", d => !d)
    .filter(d => d)
    .attr("x", d => d[0])
    .attr("y", d => d[1]);

function getPath(area) {
  var top = area.map((f, j) => [x(j), y(f[1])]),
      bottom = area.map((f, j) => [x(j), y(f[0])]).reverse();

  return line(top) + line(bottom).replace("M", "L") + "Z";
}

function getBestLabel(points) {
  var bbox = this.getBBox(),
      numValues = Math.ceil(x.invert(bbox.width + 20)),
      finder = findSpace(points, bbox, numValues);

  // Try to fit it inside, otherwise try to fit it above or below
  return finder() ||
    (points.top && finder(y.range()[1])) ||
    (points.bottom && finder(null, y.range()[0]));
}

function findSpace(points, bbox, numValues) {

  return function(top, bottom) {
    var bestRange = -Infinity,
      bestPoint,
      set,
      floor,
      ceiling,
      textY;

    // Could do this in linear time ¯\_(ツ)_/¯
    for (var i = 1; i < points.length - numValues - 1; i++) {
      set = points.slice(i, i + numValues);

      if (bottom != null) {
        floor = bottom;
        ceiling = d3.max(set, d => y(d[0]));
      } else if (top != null) {
        floor = d3.min(set, d => y(d[1]));
        ceiling = top;
      } else {
        floor = d3.min(set, d => y(d[0]));
        ceiling = d3.max(set, d => y(d[1]));
      }

      if (floor - ceiling > bbox.height + 20 && floor - ceiling > bestRange) {
        bestRange = floor - ceiling;
        if (bottom != null) {
          textY = ceiling + bbox.height / 2 + 10;
        } else if (top != null) {
          textY = floor - bbox.height / 2 - 10;
        } else {
          textY = (floor + ceiling) / 2;
        }
        bestPoint = [
          x(i + (numValues - 1) / 2),
          textY
        ];
      }
    }

    return bestPoint;
  };
}

});

d3.json("http://localhost:9090/tweets", function (tweets) {

  var data = [];

  for (var i = 0; i < tweets.length; i++) {
    data[i] = {};
    data[i]["time"] = tweets.time[i];
    data[i]["content"] = tweets.content[i];
  }

  function tabulate(data, columns) {
		var table = d3.select('body').append('table')
		var thead = table.append('thead')
		var	tbody = table.append('tbody');

		// append the header row
		thead.append('tr')
		  .selectAll('th')
		  .data(columns).enter()
		  .append('th')
		    .text(function (column) { return column; });

		// create a row for each object in the data
		var rows = tbody.selectAll('tr')
		  .data(data)
		  .enter()
		  .append('tr');

		// create a cell in each row for each column
		var cells = rows.selectAll('td')
		  .data(function (row) {
		    return columns.map(function (column) {
		      return {column: column, value: row[column]};
		    });
		  })
		  .enter()
		  .append('td')
		    .text(function (d) { return d.value; });

	  return table;
	}

	// render the table(s)
	tabulate(data, ['time', 'content']); // 2 column table

});

</script>
